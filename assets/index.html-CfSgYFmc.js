import{_ as a,c as i,a as t,o as s}from"./app-Czoex1dD.js";const p={};function n(l,e){return s(),i("div",null,e[0]||(e[0]=[t(`<h2 id="讲座-web-基础" tabindex="-1"><a class="header-anchor" href="#讲座-web-基础"><span>讲座 - Web 基础</span></a></h2><p>Web 具有按需操作的特性，需要有服务器（server）提供内容，需要客户（client）进行请求. Web 客户通常指浏览器（browser），比如 Microsoft Edge 或者 Google Chrome.</p><p>网页是一种文件，客户通知服务器，请求文件. 服务器在接到请求之后做出相应，浏览器按照一定规则组织好显示在屏幕上.</p><h3 id="web-通信" tabindex="-1"><a class="header-anchor" href="#web-通信"><span>Web 通信</span></a></h3><p>交互过程中如何保证信息被正确处理？我们需要约定，这里就是“协议（protocol）”，指的是交换信息的格式和顺序、事件发生时的操作.</p><p>准确定位请求，需要网址（URL，uniform resource locator）. URL 一般能分成三个部分：协议://主机名[:端口号]/路径[?查询].</p><p>现在讲一讲 Web 的核心协议，HTTP（Hyper-Text Transfer Protocol，超文本传输协议），它定义请求的方式和响应的方式.</p><h4 id="http-request" tabindex="-1"><a class="header-anchor" href="#http-request"><span>HTTP request</span></a></h4><p>请求方法，常见的有：</p><ol><li>GET：获取资源</li><li>POST：提交数据</li><li>PUT：更新 / 替换服务器资源</li><li>DELETE：删除服务器资源</li></ol><p><s>理论上很多方法可以混用，但是这并不好.</s></p><p>请求如何携带信息，比如说用户名和密码？有常用的三种方法：</p><ol><li><p>路径传参：<code>http://www.site.com/info/aaa/head.png</code></p></li><li><p>查询字符串传参：<code>http://www.site.com/info?username=aaa&amp;require=head</code></p></li><li><p>请求体传参：<code>http://www.site.com/info</code></p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">username</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">aaa</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">    &quot;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">telephone</span><span style="--shiki-light:#99841877;--shiki-dark:#B8A96577;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">123456789</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>[拓展]用户身份验证：可能的使用场景是个性化推送之类. 最简单的想法是使用验证码，但是这样太麻烦；一种常用验证方法是使用 Cookies，Cookie 保存在客户端，之后的请求中自动携带 Cookie 信息.</p><p>但是 Cookie 带来安全问题：一是存在第三方 Cookie，它可能多个平台同时采集用户行为，进行广告个性化推送之类；二是 Cookie 如果泄露，问题就会很严重.</p><h4 id="http-response" tabindex="-1"><a class="header-anchor" href="#http-response"><span>HTTP response</span></a></h4><p>服务器收到请求返回响应. 相应用状态码表示结果，下面是几个常见的状态码：</p><ol><li>200 OK：请求成功</li><li>400 Bad Request：请求错误</li><li>403 Forbidden：没有权限</li><li>404 Not Found：请求资源未找到</li><li>500 Internal Server Error：服务器内部错误</li></ol><p>容易发现“4”开头的都是客户端问题，“5”开头的都是服务器问题.</p><h4 id="http-调试" tabindex="-1"><a class="header-anchor" href="#http-调试"><span>HTTP 调试</span></a></h4><p>浏览器一般帮助我们处理了请求使用哪一种方法，但是我们如果想要手动发送请求，就要使用一些工具，比如 Postman / Apifox.</p><p>[拓展]HTTPS，它是 HTTP Secure，超文本传输安全协议. HTTP 的不安全之处在于信息明文传递、无法证明信息完整、无法验证身份.</p><p>改进之处是在 HTTP 上面加入 SSL / TLS.</p><h3 id="web-页面" tabindex="-1"><a class="header-anchor" href="#web-页面"><span>Web 页面</span></a></h3><h4 id="html" tabindex="-1"><a class="header-anchor" href="#html"><span>HTML</span></a></h4><p>Hyper-Text Markup Language，超文本标记语言. 其中定义了很多标签，标签表示网页内容的类型以及格式，标签内含有具体内容.</p><p>常用的 HTML 标签：略去吧，这些用用就会了.</p><p>在一个 HTML 文档中，首先要声明：<code>&lt;!DOCTYPE html&gt;</code>，然后是根标签<code>&lt;html&gt;&lt;/html&gt;</code>.</p><p>HTML 标签具有属性：</p><ol><li>class：类名</li><li>id：唯一标识符</li><li>style：样式</li><li>……</li></ol><p>需要专门介绍的是<code>&lt;div&gt;</code>标签，本身没有语义，仅仅作为一个容器.</p><h4 id="css" tabindex="-1"><a class="header-anchor" href="#css"><span>CSS</span></a></h4><p>样式表文件. 在 HTML 中用<code>&lt;link rel=&#39;stylesheet&#39; href=&#39;xxx.css&#39;&gt;</code>引用这个 CSS 文件，使得它在整个文件中都被引用.</p><p>CSS 是 Cascading Style Sheet，层叠样式表，实际上大家有兴趣可以引用两个相互矛盾的 CSS 来看看效果是什么.</p><h4 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript"><span>JavaScript</span></a></h4><p>这是一种脚本语言，可以不用编译，直接嵌入 HTML，能操纵 HTML 文件中的元素，而且写法和 c++ 很像.</p><p>有意思的是 Java 和 JavaScript 什么关系都没有，甚至不是一个公司开发的.</p><p>注意的是，最好在<code>&lt;head&gt;</code>里面引入 CSS，而在<code>&lt;body&gt;</code>中引入 JS，以实现提高加载速度的目的.</p><p>上面三者被称为前端三件套.</p><h4 id="web-开发工具" tabindex="-1"><a class="header-anchor" href="#web-开发工具"><span>Web 开发工具</span></a></h4><p>可以在浏览器中使用 F12+Fn 进入开发者模式，用 Ctrl+S 保存网页文件.</p><h3 id="web-应用基础" tabindex="-1"><a class="header-anchor" href="#web-应用基础"><span>Web 应用基础</span></a></h3><p>对于静态网页，网页的内容全部都是固定的，服务器不需要进行逻辑处理.</p><p>但是静态网页并不能满足所有的需求，这时候我们就需要考虑动态网页. 在动态网页中，服务器可能有一个模板文件，收到请求后读取特定的文件，然后进行填充.</p><p>但是服务器不一定能做完所有事，我们可以将“填充”的任务交给客户端完成. 这时候就是一种前后端分离.</p><p>一个简单的例子是在 B 站上搜索某个关键词：</p><ol><li>客户向前端服务器请求</li><li>前端服务器返回模板</li><li>网页上 JS 脚本向后端服务器请求数据</li><li>客户端收到响应进行填充</li></ol><p>这里面传输数据的格式由开发者决定，称为 API.</p><p>这与动态网页也不相同，它提升了用户体验——在动态网页情况下，返回的是一整个网页，而前后端分离时，用户会看到一个网页框架，然后内容逐渐显示出来.</p><p>[拓展]前后端分离的安全问题：攻击者可以修改 JS 中的 API，使得请求本身是错误的.</p><p>建议的之后学习路径：</p><ol><li>数据库 &amp; SQL</li><li>前端</li><li>后端</li></ol>`,52)]))}const o=a(p,[["render",n],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/posts/e7osczep/","title":"讲座 - Web 基础","lang":"zh-CN","frontmatter":{"title":"讲座 - Web 基础","createTime":"2024/11/17 14:58:03","tags":["interdisciplinarity","lecture"],"permalink":"/posts/e7osczep/","description":"讲座 - Web 基础 Web 具有按需操作的特性，需要有服务器（server）提供内容，需要客户（client）进行请求. Web 客户通常指浏览器（browser），比如 Microsoft Edge 或者 Google Chrome. 网页是一种文件，客户通知服务器，请求文件. 服务器在接到请求之后做出相应，浏览器按照一定规则组织好显示在屏幕上....","head":[["meta",{"property":"og:url","content":"https://physnya.top/posts/e7osczep/"}],["meta",{"property":"og:site_name","content":"菲兹克斯喵"}],["meta",{"property":"og:title","content":"讲座 - Web 基础"}],["meta",{"property":"og:description","content":"讲座 - Web 基础 Web 具有按需操作的特性，需要有服务器（server）提供内容，需要客户（client）进行请求. Web 客户通常指浏览器（browser），比如 Microsoft Edge 或者 Google Chrome. 网页是一种文件，客户通知服务器，请求文件. 服务器在接到请求之后做出相应，浏览器按照一定规则组织好显示在屏幕上...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-11T14:39:06.000Z"}],["meta",{"property":"article:tag","content":"interdisciplinarity"}],["meta",{"property":"article:tag","content":"lecture"}],["meta",{"property":"article:modified_time","content":"2025-02-11T14:39:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"讲座 - Web 基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-02-11T14:39:06.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":4.81,"words":1444},"git":{"updatedTime":1739284746000,"contributors":[{"name":"physnya","username":"physnya","email":"676266673@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/physnya?v=4","url":"https://github.com/physnya"}]},"autoDesc":true,"filePathRelative":"lectures/learn-web.md","categoryList":[{"id":"eed5ef","sort":10004,"name":"lectures"}],"bulletin":true}');export{o as comp,h as data};
